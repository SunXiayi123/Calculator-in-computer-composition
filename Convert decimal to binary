// file: src/dec_to_bin_calculator.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#define MAX_LINE 4096

/* Why: strict parse to avoid partial tokens like "12abc" */
static int parse_ull(const char *s, unsigned long long *out) {
    if (!s || !*s) return 0;
    for (const char *p = s; *p; ++p) if (*p == '-') return 0; /* non-negative only */
    errno = 0;
    char *end = NULL;
    unsigned long long v = strtoull(s, &end, 10);
    if (errno || end == s || *end != '\0') return 0;
    *out = v;
    return 1;
}

/* Collect division steps (remainders) for manual proof; return count. */
static size_t collect_remainders(unsigned long long x, int *r, size_t cap) {
    if (x == 0) { r[0] = 0; return 1; }
    size_t n = 0;
    while (x > 0 && n < cap) {
        r[n++] = (int)(x % 2ull);
        x /= 2ull;
    }
    return n;
}

/* Print the long division-by-2 table using the recorded remainders. */
static void print_division_steps(unsigned long long original, const int *r, size_t n) {
    if (original == 0) {
        printf("  0 �� 2 = 0  r:0\n");
        return;
    }
    unsigned long long cur = original;
    for (size_t i = 0; i < n; ++i) {
        unsigned long long q = cur / 2ull;
        int rem = (int)(cur % 2ull);
        printf("  %llu �� 2 = %llu  r:%d\n", cur, q, rem);
        cur = q;
    }
}

/* Emit binary string from reversed remainders. bufsz >= 65 */
static void remainders_to_binary(const int *r, size_t n, char *buf, size_t bufsz) {
    if (n == 1 && r[0] == 0) { snprintf(buf, bufsz, "0"); return; }
    if (bufsz < n + 1) { /* Why: avoid overflow on tiny buffers */
        snprintf(buf, bufsz, "?");
        return;
    }
    for (size_t i = 0; i < n; ++i) buf[i] = (char)('0' + r[n - 1 - i]);
    buf[n] = '\0';
}

static void process_token(const char *tok) {
    unsigned long long val = 0;
    if (!parse_ull(tok, &val)) {
        fprintf(stderr, "[skip] invalid decimal: \"%s\"\n", tok);
        return;
    }

    int rem[65];
    size_t n = collect_remainders(val, rem, 65);
    char bin[65];
    remainders_to_binary(rem, n, bin, sizeof bin);

    printf("\nDecimal: %s\n", tok);
    print_division_steps(val, rem, n);
    printf("Binary (remainders ��): %s\n", bin);
}

int main(int argc, char **argv) {
    /* Mode 1: argv tokens */
    if (argc > 1) {
        for (int i = 1; i < argc; ++i) process_token(argv[i]);
        return 0;
    }

    /* Mode 2: interactive line */
    puts("Decimal �� Binary (type numbers separated by spaces; Ctrl+D to exit)");
    puts("Example: 25 0 12 255");
    printf("> ");

    char line[MAX_LINE];
    while (fgets(line, sizeof line, stdin)) {
        const char *delims = " \t\r\n";
        char *tok = strtok(line, delims);
        if (!tok) { printf("> "); continue; }
        while (tok) {
            process_token(tok);
            tok = strtok(NULL, delims);
        }
        printf("> ");
    }
    return 0;
}

